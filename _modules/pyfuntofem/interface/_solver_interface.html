
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pyfuntofem.interface._solver_interface &#8212; FUNtoFEM .0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinxdoc.css" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">FUNtoFEM .0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">pyfuntofem.interface._solver_interface</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pyfuntofem.interface._solver_interface</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>

<span class="c1"># This file is part of the package FUNtoFEM for coupled aeroelastic simulation</span>
<span class="c1"># and design optimization.</span>

<span class="c1"># Copyright (C) 2015 Georgia Tech Research Corporation.</span>
<span class="c1"># Additional copyright (C) 2015 Kevin Jacobson, Jan Kiviaho and Graeme Kennedy.</span>
<span class="c1"># All rights reserved.</span>

<span class="c1"># FUNtoFEM is licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this software except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>

<span class="c1">#   http://www.apache.org/licenses/LICENSE-2.0</span>

<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;SolverInterface&quot;</span><span class="p">]</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>


<div class="viewcode-block" id="SolverInterface"><a class="viewcode-back" href="../../../programmers_guide.html#pyfuntofem.interface.SolverInterface">[docs]</a><span class="k">class</span> <span class="nc">SolverInterface</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A base class to define what functions solver interfaces in FUNtoFEM need</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The solver constructor is required to set discipline node locations (either :math:`x_a` or :math:`x_s`)</span>
<span class="sd">        in the funtofem body class. These values are passed via a call to either</span>
<span class="sd">        ``body.initialize_struct_nodes(struct_X)`` or ``body.initialize_aero_nodes(aero_X)``.</span>
<span class="sd">        The constructor can be used flexibly for other discipline solver specific activities (e.g. solver</span>
<span class="sd">        instantiation, reading mesh, allocating solver data).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Notional aerodynamic solver implementation ``solver``:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            # Set aerodynamic surface meshes</span>
<span class="sd">            for ibody, body in enumerate(bodies):</span>
<span class="sd">                aero_X = solver.get_mesh(ibody)</span>
<span class="sd">                body.initialize_aero_nodes(aero_X)</span>

<span class="sd">        Notional structural solver implementation ``solver``:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            # Set structural meshes</span>
<span class="sd">            for ibody, body in enumerate(bodies):</span>
<span class="sd">                struct_X = solver.get_mesh(ibody)</span>
<span class="sd">                body.initialize_struct_nodes(struct_X)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A base class to define what functions solver interfaces in FUNtoFEM need</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SolverInterface.set_variables"><a class="viewcode-back" href="../../../programmers_guide.html#pyfuntofem.interface.SolverInterface.set_variables">[docs]</a>    <span class="k">def</span> <span class="nf">set_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the design variables into the solver.</span>
<span class="sd">        The scenario and bodies objects have dictionaries of :class:`~variable.Variable` objects.</span>
<span class="sd">        The interface class should pick out which type of variables it needs and pass them into the solver</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scenario: :class:`~scenario.Scenario`</span>
<span class="sd">            The current scenario</span>
<span class="sd">        bodies: list of :class:`~body.Body` objects</span>
<span class="sd">            The bodies in the model</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Structural Solver:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            for ibody, body in enumerate(bodies):</span>
<span class="sd">                for i, var in enumerate(self.variables):</span>
<span class="sd">                    solver.set_variable(i, var.value)</span>

<span class="sd">        Aerodynamic Solver:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            for ibody, body in enumerate(bodies):</span>
<span class="sd">                for i, var in enumerate(self.variables):</span>
<span class="sd">                    solver.set_variable(i, var.value)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="SolverInterface.set_functions"><a class="viewcode-back" href="../../../programmers_guide.html#pyfuntofem.interface.SolverInterface.set_functions">[docs]</a>    <span class="k">def</span> <span class="nf">set_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the function definitions into the solver.</span>
<span class="sd">        The scenario has a list of function objects.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scenario: :class:`~scenario.Scenario`</span>
<span class="sd">            The current scenario</span>
<span class="sd">        bodies: list of :class:`~body.Body` objects</span>
<span class="sd">            The bodies in the model</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Structural Solver:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            for func in scenario.functions:</span>

<span class="sd">                # Set the structural functions in</span>
<span class="sd">                if function.adjoint and function.analysis_type == &quot;structural&quot;:</span>
<span class="sd">                    solver.set_adjoint_function(function.name, function.start, function,stop)</span>

<span class="sd">                # Tell the solver that an adjoint is needed, but the function is</span>
<span class="sd">                # not explicitly dependent on structural states</span>
<span class="sd">                elif function.adjoint and function.analysis_type != &quot;structural&quot;:</span>
<span class="sd">                    solver.set_dummy_function()</span>

<span class="sd">                # Functions such as structural mass do not need and adjoint</span>
<span class="sd">                elif not function.adjoint and function.analysis_type == &quot;structural&quot;:</span>
<span class="sd">                    solver.set_nonadjoint_function(function.name)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="SolverInterface.get_functions"><a class="viewcode-back" href="../../../programmers_guide.html#pyfuntofem.interface.SolverInterface.get_functions">[docs]</a>    <span class="k">def</span> <span class="nf">get_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Put the function values from the solver in the value attribute of the scneario&#39;s functions.</span>
<span class="sd">        The scenario has the list of function objects where the functions owned by this solver will be set.</span>
<span class="sd">        You can evaluate the functions based on the name or based on the functions set during</span>
<span class="sd">        :func:`~solver_interface.SolverInterface.set_functions`.</span>
<span class="sd">        The solver is only responsible for returning the values of functions it owns.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scenario: :class:`~scenario.Scenario`</span>
<span class="sd">            The current scenario</span>
<span class="sd">        bodies: list of :class:`~body.Body` objects</span>
<span class="sd">            The bodies in the model</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Structural Solver:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            for func in scenario.functions:</span>

<span class="sd">                # Set the structural functions in</span>
<span class="sd">                if func.analysis_type == &quot;structural&quot;:</span>
<span class="sd">                    if func.name == &quot;mass&quot;:</span>
<span class="sd">                        func.value = solver.evaluate_mass()</span>
<span class="sd">                    elif func.name == &quot;ksfailure&quot;:</span>
<span class="sd">                        func.value = solver.get_ksfailure()</span>
<span class="sd">                    else:</span>
<span class="sd">                        print(&quot;Unknown structural function in get_functions&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="SolverInterface.get_function_gradients"><a class="viewcode-back" href="../../../programmers_guide.html#pyfuntofem.interface.SolverInterface.get_function_gradients">[docs]</a>    <span class="k">def</span> <span class="nf">get_function_gradients</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the derivatives of all the functions with respect to design variables associated with this solver.</span>

<span class="sd">        Each solver sets the function gradients for its own variables into the function objects using either</span>
<span class="sd">        ``function.set_gradient(var, value)`` or ``function.add_gradient(var, vaule)``. Note that before</span>
<span class="sd">        this function is called, all gradient components are zeroed.</span>

<span class="sd">        The derivatives are stored in a dictionary in each function class. As a result, the gradients are</span>
<span class="sd">        stored in an unordered format. The gradients returned by ``model.get_function_gradients()`` are</span>
<span class="sd">        flattened into a list of lists whose order is determined by the variable list stored in the model</span>
<span class="sd">        class.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scenario: :class:`~scenario.Scenario`</span>
<span class="sd">            The current scenario</span>
<span class="sd">        bodies: list of :class:`~body.Body` objects</span>
<span class="sd">            The bodies in the model</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Aerodynamic Solver:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            # Make sure the gradient is consistent across all processors before setting</span>
<span class="sd">            # the values</span>
<span class="sd">            grad = self.comm.allreduce(grad)</span>

<span class="sd">            for i, func in enumerate(scenario.functions):</span>
<span class="sd">                for j, var in enumerate(self.variables):</span>
<span class="sd">                    func.set_derivatives(var, grad[i, j])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="SolverInterface.get_coordinate_derivatives"><a class="viewcode-back" href="../../../programmers_guide.html#pyfuntofem.interface.SolverInterface.get_coordinate_derivatives">[docs]</a>    <span class="k">def</span> <span class="nf">get_coordinate_derivatives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add the solver&#39;s contributions to the coordinate derivatives for this time step or the total value</span>
<span class="sd">        for the steady case. The coordinate derivatives are stored in the body objects in the aero_shape_term</span>
<span class="sd">        and struct_shape_term attributes.</span>

<span class="sd">        For time dependent problems, this is called at the end of every time step during reverse marching.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scenario: :class:`~scenario.Scenario`</span>
<span class="sd">            The current scenario</span>
<span class="sd">        bodies: list of :class:`~body.Body` objects</span>
<span class="sd">            The bodies in the model</span>
<span class="sd">        step: int</span>
<span class="sd">            The time step number</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Aerodynamic Solver:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            nfunctions = scenario.count_adjoint_functions()</span>
<span class="sd">            for ibody, body in enumerate(bodies):</span>
<span class="sd">                lam_x, lam_y, lam_Z = solver.extract_coordinate_derivatives(ibody, step)</span>

<span class="sd">                aero_shape_term = body.get_aero_coordinate_derivatives(scenario)</span>
<span class="sd">                aero_shape_term[ ::3,:nfunctions] += lam_x[:,:]</span>
<span class="sd">                aero_shape_term[1::3,:nfunctions] += lam_y[:,:]</span>
<span class="sd">                aero_shape_term[2::3,:nfunctions] += lam_z[:,:]</span>

<span class="sd">        Structural Solver:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            for ibody, body in enumerate(bodies):</span>
<span class="sd">                # Add the derivatives to the body</span>
<span class="sd">                lam_x, lam_y, lam_Z = solver.extract_coordinate_derivatives(ibody, step)</span>

<span class="sd">                struct_shape_term = body.get_struct_coordinate_derivatives(scenario)</span>
<span class="sd">                struct_shape_term[ ::3,:nfunctions] += lam_x[:,:]</span>
<span class="sd">                struct_shape_term[1::3,:nfunctions] += lam_y[:,:]</span>
<span class="sd">                struct_shape_term[2::3,:nfunctions] += lam_z[:,:]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="SolverInterface.initialize"><a class="viewcode-back" href="../../../programmers_guide.html#pyfuntofem.interface.SolverInterface.initialize">[docs]</a>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set up anything that is necessary for a specific scenario prior to calls to ``iterate``.</span>
<span class="sd">        A requirement is that discipline solvers update their mesh representations to be consistent</span>
<span class="sd">        with the coordinates in the bodies. These coordinate locations can be obtained by</span>
<span class="sd">        calling ``body.get_aero_nodes`` (:math:`x_a`) or ``body.get_struct_nodes`` (:math:`x_s`),</span>
<span class="sd">        respectively. These coordinates may be updated as a result of design changes.</span>

<span class="sd">        Note, it is possible that a discipline solver mesh representation is updated by reading a mesh file</span>
<span class="sd">        instead of accepting the funtofem body representation. Ultimately, the requirement is that the funtofem</span>
<span class="sd">        body mesh representations ``body.aero_X`` and ``body.struct_X`` and their corresponding discipline solver</span>
<span class="sd">        mesh representations are consistent.</span>

<span class="sd">        The initialize step may accomodate other useful activities such as data allocation,</span>
<span class="sd">        setting initial conditions, etc.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scenario: :class:`~scenario.Scenario`</span>
<span class="sd">            The current scenario</span>
<span class="sd">        bodies: list of :class:`~body.Body` objects</span>
<span class="sd">            The bodies in the model</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Aerodynamic Solver:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            # Set in the new aerodynamic surface meshes</span>
<span class="sd">            for ibody, body in enumerate(bodies):</span>
<span class="sd">                aero_X = body.get_aero_nodes()</span>
<span class="sd">                solver.set_surface_node_locations(ibody, aero_X)</span>

<span class="sd">           # Initialize internal solver data in preparation for a flow solver iterations</span>
<span class="sd">           solver.initialize()</span>

<span class="sd">        Structural Solver:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            # Set the new structural surface mesh</span>
<span class="sd">            for ibody, body in enumerate(bodies):</span>
<span class="sd">                struct_X = body.get_struct_nodes()</span>
<span class="sd">                solver.set_structural_node_locations(ibody, struct_X)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="SolverInterface.iterate"><a class="viewcode-back" href="../../../programmers_guide.html#pyfuntofem.interface.SolverInterface.iterate">[docs]</a>    <span class="k">def</span> <span class="nf">iterate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate on the primal residual equation for the present discipline solver. Called in NLBGS solver.</span>

<span class="sd">        For an aerodynamic solver, this might include:</span>

<span class="sd">        #. Obtain displacements at aerodynamic surface nodes :math:`u_a` from funtofem body objects</span>
<span class="sd">        #. Deform the meshes</span>
<span class="sd">        #. Solve for the new aerodynamic state :math:`q`</span>
<span class="sd">        #. Integrate and localize aerodynamic surface forces :math:`f_a` at aerodynamic surface node locations</span>

<span class="sd">        For a structural solver:</span>

<span class="sd">        #. Obtain the forces at structural nodes :math:`f_s`</span>
<span class="sd">        #. Solve for new displacement state :math:`u_s`</span>
<span class="sd">        #. Set new structural displacements :math:`u_s`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scenario: :class:`~scenario.Scenario`</span>
<span class="sd">            The current scenario</span>
<span class="sd">        bodies: list of :class:`~body.Body` objects</span>
<span class="sd">            The bodies in the model</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Aerodynamic Solver:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            # Get the surface node locations and temperatures</span>
<span class="sd">            for ibody, body in enumerate(bodies):</span>
<span class="sd">                aero_disps = body.get_aero_disps(scenario) # May return None if not aeroelastic</span>
<span class="sd">                if aero_disps is not None:</span>
<span class="sd">                    solver.input_surface_deformation(ibody, aero_disps)</span>

<span class="sd">                aero_temps = body.get_aero_temps(scenario) # May return None if not aerothermal</span>
<span class="sd">                if aero_temps is not None:</span>
<span class="sd">                    solver.input_surface_temperatures(ibody, aero_temps)</span>

<span class="sd">            # Advance the solver</span>
<span class="sd">            solver.iterate()</span>

<span class="sd">            # Extract the aerodynamic forces at the nodes and the corresponding</span>
<span class="sd">            # area-weighted normal component of the heat flux</span>
<span class="sd">            for ibody, body in enumerate(bodies):</span>
<span class="sd">                aero_loads = body.get_aero_loads(scenario)</span>
<span class="sd">                if aero_loads is not None:</span>
<span class="sd">                    aero_loads[:] = solver.get_surface_forces(ibody)</span>

<span class="sd">                aero_flux = body.get_aero_heat_flux(scenario)</span>
<span class="sd">                if aero_flux is not None:</span>
<span class="sd">                    aero_flux[:] = solver.get_surface_heat_flux(ibody)</span>

<span class="sd">        Structural Solver:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            # Input the forces and/or heat flux to the structure</span>
<span class="sd">            for ibody, body in enumerate(bodies):</span>
<span class="sd">                struct_loads = body.get_struct_loads(scenario)</span>
<span class="sd">                if struct_loads is not None:</span>
<span class="sd">                    solver.input_forces(ibody, struct_loads)</span>

<span class="sd">                struct_flux = body.get_struct_heat_flux(scenario)</span>
<span class="sd">                if struct_flux is not None:</span>
<span class="sd">                    solver.input_heat_flux(ibody, struct_flux)</span>

<span class="sd">            # Solve the problem with the forces/heat loads</span>
<span class="sd">            solver.iterate()</span>

<span class="sd">            # Extract the displacemets</span>
<span class="sd">                struct_disps = body.get_struct_disps(scenario)</span>
<span class="sd">                if struct_disps is not None:</span>
<span class="sd">                    struct_disps[:] = solver.get_displacements(ibody)</span>

<span class="sd">                struct_temps = body.get_struct_temps(scenario)</span>
<span class="sd">                if struct_temps is not None:</span>
<span class="sd">                    struct_disps[:] = solver.get_temperatures(ibody)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="SolverInterface.post"><a class="viewcode-back" href="../../../programmers_guide.html#pyfuntofem.interface.SolverInterface.post">[docs]</a>    <span class="k">def</span> <span class="nf">post</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform any tasks the solver needs to do after the forward steps are complete, e.g., evaluate functions,</span>
<span class="sd">        post-process, deallocate unneeded memory.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scenario: :class:`~scenario.Scenario`</span>
<span class="sd">            The current scenario</span>
<span class="sd">        bodies: list of :class:`~body.Body` objects</span>
<span class="sd">            The bodies in the model</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="SolverInterface.initialize_adjoint"><a class="viewcode-back" href="../../../programmers_guide.html#pyfuntofem.interface.SolverInterface.initialize_adjoint">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform any tasks the solver needs to do before taking adjoint steps</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scenario: :class:`~scenario.Scenario`</span>
<span class="sd">            The current scenario</span>
<span class="sd">        bodies: list of :class:`~body.Body` objects</span>
<span class="sd">            The bodies in the model</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="SolverInterface.iterate_adjoint"><a class="viewcode-back" href="../../../programmers_guide.html#pyfuntofem.interface.SolverInterface.iterate_adjoint">[docs]</a>    <span class="k">def</span> <span class="nf">iterate_adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adjoint iteration for the solver.</span>

<span class="sd">        For an aerodynamic solver this will include:</span>

<span class="sd">        #. Obtain the adjoint-Jacobian product of the surface forces from the body classes</span>
<span class="sd">        #. Obtain the adjoint-Jacobian product of the surface heat fluxes from the body classes</span>
<span class="sd">        #. Set these values into the adjoint solver</span>
<span class="sd">        #. Solve for the aerodynamic adjoint</span>
<span class="sd">        #. Solve the grid adjoint</span>
<span class="sd">        #. Compute the output adjoint-Jacobian products</span>
<span class="sd">        #. Set the adjoint-Jacobian product of the aerodynamic displacements into the body classes</span>
<span class="sd">        #. Set the adjoint-Jacobian product of the aerodynamic surface temperatures into the body classes</span>

<span class="sd">        For a structural solver this will include:</span>

<span class="sd">        #. Get the displacement adjoint-Jacobian product from the body classes</span>
<span class="sd">        #. Get the temperature adjoint-Jacobian product from the body classes</span>
<span class="sd">        #. Set the adjoint-Jacobian products into the right-hand-side of the structural solver</span>
<span class="sd">        #. Solve the structural or thermomechanical adjoint equations</span>
<span class="sd">        #. Compute the output adjoint-Jacobian products</span>
<span class="sd">        #. Set the adjoint-Jacobian product of the structural forces into the body classes</span>
<span class="sd">        #. Set the adjoint-Jacobian product of the structural heat flux into the body classes</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scenario: :class:`~scenario.Scenario`</span>
<span class="sd">            The current scenario</span>
<span class="sd">        bodies: list of :class:`~body.Body` objects</span>
<span class="sd">            The bodies in the model</span>
<span class="sd">        step: int</span>
<span class="sd">            The step number. Will start at the final step and march backwards to 0, the initial condition.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Aerodynamic Solver:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            # Set the inputs to the aerodynamic adjoint</span>
<span class="sd">            for ibody, body in enumerate(bodies):</span>
<span class="sd">                # Get the adjoint-Jacobian product for the aero_loads. This may be None</span>
<span class="sd">                # if it is not defined</span>
<span class="sd">                aero_loads_ajp = body.get_aero_loads_ajp(scenario)</span>
<span class="sd">                if aero_loads_ajp is not None:</span>
<span class="sd">                    # Note: This part may or may not be in the solver itself. This</span>
<span class="sd">                    # hypothetical code is like FUN3D where the integration adjoint</span>
<span class="sd">                    # terms are solved externally and then set into the solver.</span>

<span class="sd">                    # Solve the aero force integration adjoint equation</span>
<span class="sd">                    # dF/dfA^{T} * psi_{F} = - dL/dfA^{T} * psi_L = - aero_loads_ajp.</span>
<span class="sd">                    # Note that in this case dF/dfA = I.</span>
<span class="sd">                    psi_F = -aero_loads_ajp</span>

<span class="sd">                    for ifunc, func in enumerate(scenario.functions):</span>
<span class="sd">                        solver.set_aero_forces_adjoint(ibody, psi_F[:, ifunc])</span>

<span class="sd">                # Get the adjoint-Jacobian product for the aero_flux. This may be</span>
<span class="sd">                # None if it is not defined</span>
<span class="sd">                aero_flux_ajp = body.get_aero_heat_flux_ajp(scenario)</span>
<span class="sd">                if aero_flux_ajp is not None:</span>
<span class="sd">                    # Solve the aero heat flux integration</span>
<span class="sd">                    # dH/dhA^{T} * psi_H = - dQ/dhA^{T} * psi_Q = - aero_flux_ajp</span>
<span class="sd">                    psi_H = -aero_flux_ajp</span>

<span class="sd">                    for ifunc, func in enumerate(scenario.functions):</span>
<span class="sd">                        solver.set_aero_flux_adjoint(ibody, psi_H[:, ifunc])</span>

<span class="sd">            # Iterate on the adjoint equations</span>
<span class="sd">            solver.iterate_adjoint()</span>

<span class="sd">            # Extract the output adjoint-Jacobian products from the solver</span>
<span class="sd">            for ibody, body in enumerate(bodies):</span>
<span class="sd">                aero_disps_ajp = body.get_aero_disps_ajp(scenario)</span>
<span class="sd">                if aero_disps_ajp is not None:</span>
<span class="sd">                    for ifunc, func in enumerate(scenario.functions):</span>
<span class="sd">                        dfdxA = solver.get_disp_adjoint_product(ibody, ifunc)</span>
<span class="sd">                        aero_disps_ajp[:, ifunc] = dfdxA</span>

<span class="sd">                aero_temps_ajp = body.get_aero_temps_ajp(scenario)</span>
<span class="sd">                if aero_temps_ajp is not None:</span>
<span class="sd">                    for ifunc, func in enumerate(scenario.functions):</span>
<span class="sd">                        dfdtA = solver.get_temp_adjoint_product(ibody, ifunc)</span>
<span class="sd">                        aero_temps_ajp[:, ifunc] = dfdtA</span>

<span class="sd">        Structural Solver:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            # Outer loop over the number of functions of interest</span>
<span class="sd">            for ifunc, func in enumerate(scenario.functions):</span>
<span class="sd">                rhs[:] = -dfdu[ifunc] # Set the right-hand-side</span>

<span class="sd">                # Set the inputs to the structural adjoint</span>
<span class="sd">                for ibody, body in enumerate(bodies):</span>
<span class="sd">                    struct_disps_ajp = body.get_struct_disps_ajp(scenario)</span>
<span class="sd">                    if struct_disps_ajp is not None:</span>
<span class="sd">                        # Add the contributions to the adjoint right-hand-side</span>
<span class="sd">                        rhs[load_locations] -= struct_disps_ajp</span>

<span class="sd">                    struct_temps_ajp = body.get_struct_temps_ajp(scenario)</span>
<span class="sd">                    if struct_temps_ajp is not None:</span>
<span class="sd">                        rhs[temp_locations] -= struct_temps_ajp</span>

<span class="sd">                # Solve the adjoint</span>
<span class="sd">                solver.solve_adjoint(rhs)</span>

<span class="sd">                # Extract the load and heat-flux ajdoint-vector products</span>
<span class="sd">                psi_S = solver.get_adjoint()</span>

<span class="sd">                # Here the required adjoint vector products are</span>
<span class="sd">                # struct_loads_ajp = psi_S^{T} * dS/dfS</span>
<span class="sd">                # struct_flux_ajp = psi_S^{T} * dS/fhS</span>
<span class="sd">                # We use the residual S = r(u) - fS - hS</span>
<span class="sd">                for ibody, body in enumerate(bodies):</span>
<span class="sd">                    struct_loads_ajp = body.get_struct_loads_ajp(scenario)</span>
<span class="sd">                    if struct_loads_ajp is not None:</span>
<span class="sd">                        struct_loads_ajp[:] = -psi_S[load_locations]</span>

<span class="sd">                    struct_flux_ajp = body.get_struct_heat_flux_ajp(scenario)</span>
<span class="sd">                    if struct_flux_ajp is not None:</span>
<span class="sd">                        struct_flux_ajp[:] = -psi_S[temp_locations]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="SolverInterface.post_adjoint"><a class="viewcode-back" href="../../../programmers_guide.html#pyfuntofem.interface.SolverInterface.post_adjoint">[docs]</a>    <span class="k">def</span> <span class="nf">post_adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Any actions that need to be performed after completing the adjoint solve, e.g., evaluating gradients, deallocating memory, etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="SolverInterface.set_states"><a class="viewcode-back" href="../../../programmers_guide.html#pyfuntofem.interface.SolverInterface.set_states">[docs]</a>    <span class="k">def</span> <span class="nf">set_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load the states (aero_loads, struct_disps) associated with this step either from memory or the disk for</span>
<span class="sd">        the transfer scheme to linearize about. This function is called at the beginning of each adjoint</span>
<span class="sd">        step in time dependent problems.</span>

<span class="sd">        **Note: in the NLBGS algorithm the transfer scheme uses the structural displacements from the prior step.</span>
<span class="sd">        set_states will request the states from the previous step but then ask the structural solver to linearize</span>
<span class="sd">        about the current step in iterate_adjoint**</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scenario: :class:`~scenario.Scenario`</span>
<span class="sd">            The current scenario</span>
<span class="sd">        bodies: list of :class:`~body.Body` objects</span>
<span class="sd">            The bodies in the model</span>
<span class="sd">        step: int</span>
<span class="sd">            The time step number that the driver wants the states from</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Structural Solver:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            # Find the step&#39;s values on the disk</span>
<span class="sd">            disps_hist = solver.load_state(step)</span>

<span class="sd">            # Set the structural displacements for the transfer scheme residuals to linearize about</span>
<span class="sd">            for ibody,body in enumerate(bodies):</span>
<span class="sd">                body.struct_disps = disps_hist[ibody]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="SolverInterface.step_pre"><a class="viewcode-back" href="../../../programmers_guide.html#pyfuntofem.interface.SolverInterface.step_pre">[docs]</a>    <span class="k">def</span> <span class="nf">step_pre</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Operations before at a step in an FSI subiteration case. Called in NLBGS with FSI subiterations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scenario: :class:`~scenario.Scenario`</span>
<span class="sd">            The current scenario</span>
<span class="sd">        bodies: list of :class:`~body.Body` objects</span>
<span class="sd">            The bodies in the model</span>
<span class="sd">        step: int</span>
<span class="sd">            The step number. Will start at the final step and march backwards to 0, the initial condition.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="SolverInterface.step_solver"><a class="viewcode-back" href="../../../programmers_guide.html#pyfuntofem.interface.SolverInterface.step_solver">[docs]</a>    <span class="k">def</span> <span class="nf">step_solver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">fsi_subiter</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Step in an FSI subiteration case. Called in NLBGS with FSI subiterations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scenario: :class:`~scenario.Scenario`</span>
<span class="sd">            The current scenario</span>
<span class="sd">        bodies: list of :class:`~body.Body` objects</span>
<span class="sd">            The bodies in the model</span>
<span class="sd">        step: int</span>
<span class="sd">            The step number. Will start at the final step and march backwards to 0, the initial condition.</span>
<span class="sd">        fsi_subiter: int</span>
<span class="sd">            The FSI subiteration number</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="SolverInterface.step_post"><a class="viewcode-back" href="../../../programmers_guide.html#pyfuntofem.interface.SolverInterface.step_post">[docs]</a>    <span class="k">def</span> <span class="nf">step_post</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Operations after at a step in an FSI subiteration case. Called in NLBGS with FSI subiterations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scenario: :class:`~scenario.Scenario`</span>
<span class="sd">            The current scenario</span>
<span class="sd">        bodies: list of :class:`~body.Body` objects</span>
<span class="sd">            The bodies in the model</span>
<span class="sd">        step: int</span>
<span class="sd">            The step number. Will start at the final step and march backwards to 0, the initial condition.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="SolverInterface.test_adjoint"><a class="viewcode-back" href="../../../programmers_guide.html#pyfuntofem.interface.SolverInterface.test_adjoint">[docs]</a>    <span class="k">def</span> <span class="nf">test_adjoint</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">solver_type</span><span class="p">,</span>
        <span class="n">scenario</span><span class="p">,</span>
        <span class="n">bodies</span><span class="p">,</span>
        <span class="n">step</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
        <span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test the adjoint implementation depending on the solver type.</span>

<span class="sd">        This test evaluates the consistency between the forward and adjoint modes.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">solver_type</span> <span class="o">==</span> <span class="s2">&quot;flow&quot;</span> <span class="ow">or</span> <span class="n">solver_type</span> <span class="o">==</span> <span class="s2">&quot;aerodynamic&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_test_flow_adjoint</span><span class="p">(</span>
                <span class="n">scenario</span><span class="p">,</span>
                <span class="n">bodies</span><span class="p">,</span>
                <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">,</span>
                <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span>
                <span class="n">complex_step</span><span class="o">=</span><span class="n">complex_step</span><span class="p">,</span>
                <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">solver_type</span> <span class="o">==</span> <span class="s2">&quot;structural&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_test_struct_adjoint</span><span class="p">(</span>
                <span class="n">scenario</span><span class="p">,</span>
                <span class="n">bodies</span><span class="p">,</span>
                <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">,</span>
                <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span>
                <span class="n">complex_step</span><span class="o">=</span><span class="n">complex_step</span><span class="p">,</span>
                <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Unrecognized solver type in test_adjoint&quot;</span><span class="p">)</span>

        <span class="c1"># Return true if no test has been performed</span>
        <span class="k">return</span> <span class="kc">True</span></div>

    <span class="k">def</span> <span class="nf">_test_flow_adjoint</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-6</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test to see if the adjoint methods are implemented correctly</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">scenario</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span>
            <span class="n">func</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_functions</span><span class="p">(</span><span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_variables</span><span class="p">(</span><span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">body</span> <span class="ow">in</span> <span class="n">bodies</span><span class="p">:</span>
            <span class="n">body</span><span class="o">.</span><span class="n">initialize_variables</span><span class="p">(</span><span class="n">scenario</span><span class="p">)</span>

        <span class="c1"># Comptue one step of the forward solution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iterate</span><span class="p">(</span><span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">)</span>

        <span class="c1"># Evaluate and store the functions of interest</span>
        <span class="n">fvals_init</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_functions</span><span class="p">(</span><span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">scenario</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span>
            <span class="n">fvals_init</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

        <span class="c1"># Save the output forces and heat fluxes</span>
        <span class="n">aero_loads_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">aero_flux_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">body</span> <span class="ow">in</span> <span class="n">bodies</span><span class="p">:</span>
            <span class="n">aero_loads</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">get_aero_loads</span><span class="p">(</span><span class="n">scenario</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">aero_loads</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">aero_loads_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aero_loads</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

            <span class="n">aero_flux</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">get_aero_heat_flux</span><span class="p">(</span><span class="n">scenario</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">aero_flux</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">aero_flux_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aero_flux</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

        <span class="c1"># Initialize the bodies for the adjoint computation</span>
        <span class="k">for</span> <span class="n">body</span> <span class="ow">in</span> <span class="n">bodies</span><span class="p">:</span>
            <span class="n">body</span><span class="o">.</span><span class="n">initialize_adjoint_variables</span><span class="p">(</span><span class="n">scenario</span><span class="p">)</span>

            <span class="n">aero_loads_ajp</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">get_aero_loads_ajp</span><span class="p">(</span><span class="n">scenario</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">aero_loads_ajp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="n">aero_loads_ajp</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">aero_loads_ajp</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

            <span class="n">aero_flux_ajp</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">get_aero_heat_flux_ajp</span><span class="p">(</span><span class="n">scenario</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">aero_flux_ajp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="n">aero_flux_ajp</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">aero_flux_ajp</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Compute one step of the adjoint</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize_adjoint</span><span class="p">(</span><span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iterate_adjoint</span><span class="p">(</span><span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">post_adjoint</span><span class="p">(</span><span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">)</span>

        <span class="c1"># Perturb the displacements and surface temperatures</span>
        <span class="n">adjoint_product</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">disp_pert_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">temp_pert_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">body</span> <span class="ow">in</span> <span class="n">bodies</span><span class="p">:</span>
            <span class="n">body</span><span class="o">.</span><span class="n">initialize_variables</span><span class="p">(</span><span class="n">scenario</span><span class="p">)</span>

            <span class="n">aero_disps</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">get_aero_disps</span><span class="p">(</span><span class="n">scenario</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">aero_disps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">pert</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">aero_disps</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">complex_step</span><span class="p">:</span>
                    <span class="n">aero_disps</span><span class="p">[:]</span> <span class="o">+=</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">epsilon</span> <span class="o">*</span> <span class="n">pert</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">aero_disps</span><span class="p">[:]</span> <span class="o">+=</span> <span class="n">epsilon</span> <span class="o">*</span> <span class="n">pert</span>
                <span class="n">disp_pert_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pert</span><span class="p">)</span>

            <span class="n">aero_temps</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">get_aero_temps</span><span class="p">(</span><span class="n">scenario</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">aero_temps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">pert</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">aero_temps</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">complex_step</span><span class="p">:</span>
                    <span class="n">aero_temps</span><span class="p">[:]</span> <span class="o">+=</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">epsilon</span> <span class="o">*</span> <span class="n">pert</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">aero_temps</span><span class="p">[:]</span> <span class="o">+=</span> <span class="n">epsilon</span> <span class="o">*</span> <span class="n">pert</span>
                <span class="n">temp_pert_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pert</span><span class="p">)</span>

            <span class="c1"># Take the dot-product with the exact adjoint computation</span>
            <span class="n">aero_disps_ajp</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">get_aero_disps_ajp</span><span class="p">(</span><span class="n">scenario</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">aero_disps_ajp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">adjoint_product</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">aero_disps_ajp</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">disp_pert_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

            <span class="n">aero_temps_ajp</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">get_aero_temps_ajp</span><span class="p">(</span><span class="n">scenario</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">aero_temps_ajp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">adjoint_product</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">aero_temps_ajp</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">temp_pert_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Sum up the result across all processors</span>
        <span class="n">adjoint_product</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="n">adjoint_product</span><span class="p">)</span>

        <span class="c1"># Run the perturbed aerodynamic simulation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iterate</span><span class="p">(</span><span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">)</span>

        <span class="c1"># Evaluate and store the functions of interest</span>
        <span class="n">fvals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_functions</span><span class="p">(</span><span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">scenario</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span>
            <span class="n">fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

        <span class="c1"># Compute the finite-difference approximation</span>
        <span class="k">if</span> <span class="n">complex_step</span><span class="p">:</span>
            <span class="n">fd_product</span> <span class="o">=</span> <span class="n">fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span> <span class="o">/</span> <span class="n">epsilon</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fd_product</span> <span class="o">=</span> <span class="p">(</span><span class="n">fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">fvals_init</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">epsilon</span>
        <span class="k">for</span> <span class="n">body</span> <span class="ow">in</span> <span class="n">bodies</span><span class="p">:</span>
            <span class="n">aero_loads</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">get_aero_loads</span><span class="p">(</span><span class="n">scenario</span><span class="p">)</span>
            <span class="n">aero_loads_ajp</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">get_aero_loads_ajp</span><span class="p">(</span><span class="n">scenario</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">aero_loads</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">aero_loads_ajp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">aero_loads_copy</span> <span class="o">=</span> <span class="n">aero_loads_list</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">complex_step</span><span class="p">:</span>
                    <span class="n">fd</span> <span class="o">=</span> <span class="n">aero_loads</span><span class="o">.</span><span class="n">imag</span> <span class="o">/</span> <span class="n">epsilon</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fd</span> <span class="o">=</span> <span class="p">(</span><span class="n">aero_loads</span> <span class="o">-</span> <span class="n">aero_loads_copy</span><span class="p">)</span> <span class="o">/</span> <span class="n">epsilon</span>
                <span class="n">fd_product</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">aero_loads_ajp</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>

            <span class="n">aero_flux</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">get_aero_heat_flux</span><span class="p">(</span><span class="n">scenario</span><span class="p">)</span>
            <span class="n">aero_flux_ajp</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">get_aero_heat_flux_ajp</span><span class="p">(</span><span class="n">scenario</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">aero_flux</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">aero_flux_ajp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">aero_flux_copy</span> <span class="o">=</span> <span class="n">aero_flux_list</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">complex_step</span><span class="p">:</span>
                    <span class="n">fd</span> <span class="o">=</span> <span class="n">aero_flux</span><span class="o">.</span><span class="n">imag</span> <span class="o">/</span> <span class="n">epsilon</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fd</span> <span class="o">=</span> <span class="p">(</span><span class="n">aero_flux</span> <span class="o">-</span> <span class="n">aero_flux_copy</span><span class="p">)</span> <span class="o">/</span> <span class="n">epsilon</span>
                <span class="n">fd_product</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">aero_flux_ajp</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Compute the finite-differenc approximation</span>
        <span class="n">fd_product</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="n">fd_product</span><span class="p">)</span>

        <span class="n">fail</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">rel_err</span> <span class="o">=</span> <span class="p">(</span><span class="n">adjoint_product</span> <span class="o">-</span> <span class="n">fd_product</span><span class="p">)</span> <span class="o">/</span> <span class="n">fd_product</span>
            <span class="n">fail</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">rel_err</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">rtol</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Flow solver adjoint result:           &quot;</span><span class="p">,</span> <span class="n">adjoint_product</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Flow solver finite-difference result: &quot;</span><span class="p">,</span> <span class="n">fd_product</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Flow solver relative error:           &quot;</span><span class="p">,</span> <span class="n">rel_err</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Flow solver fail flag:                &quot;</span><span class="p">,</span> <span class="n">fail</span><span class="p">)</span>

        <span class="n">fail</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">fail</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fail</span>

    <span class="k">def</span> <span class="nf">_test_struct_adjoint</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-6</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test to see if the adjoint methods are implemented correctly</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">scenario</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span>
            <span class="n">func</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_variables</span><span class="p">(</span><span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_functions</span><span class="p">(</span><span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">get_functions</span><span class="p">(</span><span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">body</span> <span class="ow">in</span> <span class="n">bodies</span><span class="p">:</span>
            <span class="n">body</span><span class="o">.</span><span class="n">initialize_variables</span><span class="p">(</span><span class="n">scenario</span><span class="p">)</span>

        <span class="c1"># Set random loads and heat fluxes</span>
        <span class="k">for</span> <span class="n">body</span> <span class="ow">in</span> <span class="n">bodies</span><span class="p">:</span>
            <span class="n">struct_loads</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">get_struct_loads</span><span class="p">(</span><span class="n">scenario</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">struct_loads</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="n">struct_loads</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">body</span><span class="o">.</span><span class="n">struct_loads_saved</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">struct_loads</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">struct_loads_saved</span>

            <span class="n">struct_flux</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">get_struct_heat_flux</span><span class="p">(</span><span class="n">scenario</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">struct_flux</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="n">struct_flux</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">body</span><span class="o">.</span><span class="n">struct_flux_saved</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">struct_flux</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">struct_flux_saved</span>

        <span class="c1"># Comptue one step of the forward solution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iterate</span><span class="p">(</span><span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">)</span>

        <span class="c1"># Evaluate and store the functions of interest</span>
        <span class="n">fvals_init</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_functions</span><span class="p">(</span><span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">scenario</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span>
            <span class="n">fvals_init</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

        <span class="c1"># Save the output forces and heat fluxes</span>
        <span class="n">struct_disps_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">struct_temps_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">body</span> <span class="ow">in</span> <span class="n">bodies</span><span class="p">:</span>
            <span class="n">struct_disps</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">get_struct_disps</span><span class="p">(</span><span class="n">scenario</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">struct_disps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">struct_disps_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">struct_disps</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

            <span class="n">struct_temps</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">get_struct_temps</span><span class="p">(</span><span class="n">scenario</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">struct_temps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">struct_temps_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">struct_temps</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

        <span class="c1"># Initialize the bodies for the adjoint computation</span>
        <span class="k">for</span> <span class="n">body</span> <span class="ow">in</span> <span class="n">bodies</span><span class="p">:</span>
            <span class="n">body</span><span class="o">.</span><span class="n">initialize_adjoint_variables</span><span class="p">(</span><span class="n">scenario</span><span class="p">)</span>

            <span class="n">struct_disps_ajp</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">get_struct_disps_ajp</span><span class="p">(</span><span class="n">scenario</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">struct_disps_ajp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="n">struct_disps_ajp</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">struct_disps_ajp</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

            <span class="n">struct_temps_ajp</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">get_struct_temps_ajp</span><span class="p">(</span><span class="n">scenario</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">struct_temps_ajp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="n">struct_temps_ajp</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">struct_temps_ajp</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Compute one step of the adjoint</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize_adjoint</span><span class="p">(</span><span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iterate_adjoint</span><span class="p">(</span><span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">post_adjoint</span><span class="p">(</span><span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">)</span>

        <span class="c1"># Perturb the displacements and surface temperatures</span>
        <span class="n">adjoint_product</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">load_pert_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">flux_pert_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">body</span> <span class="ow">in</span> <span class="n">bodies</span><span class="p">:</span>
            <span class="n">body</span><span class="o">.</span><span class="n">initialize_variables</span><span class="p">(</span><span class="n">scenario</span><span class="p">)</span>

            <span class="c1"># Reset the structural loads and heat fluxes</span>
            <span class="n">struct_loads</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">get_struct_loads</span><span class="p">(</span><span class="n">scenario</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">struct_loads</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">struct_loads</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">struct_loads_saved</span>

            <span class="n">struct_flux</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">get_struct_heat_flux</span><span class="p">(</span><span class="n">scenario</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">struct_flux</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">struct_flux</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">struct_flux_saved</span>

            <span class="c1"># Perturb the structural loads and heat fluxes</span>
            <span class="n">struct_loads</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">get_struct_loads</span><span class="p">(</span><span class="n">scenario</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">struct_loads</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">pert</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">struct_loads</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">complex_step</span><span class="p">:</span>
                    <span class="n">struct_loads</span><span class="p">[:]</span> <span class="o">+=</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">epsilon</span> <span class="o">*</span> <span class="n">pert</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">struct_loads</span><span class="p">[:]</span> <span class="o">+=</span> <span class="n">epsilon</span> <span class="o">*</span> <span class="n">pert</span>
                <span class="n">load_pert_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pert</span><span class="p">)</span>

            <span class="n">struct_flux</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">get_struct_heat_flux</span><span class="p">(</span><span class="n">scenario</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">struct_flux</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">pert</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">struct_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">complex_step</span><span class="p">:</span>
                    <span class="n">struct_flux</span><span class="p">[:]</span> <span class="o">+=</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">epsilon</span> <span class="o">*</span> <span class="n">pert</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">struct_flux</span><span class="p">[:]</span> <span class="o">+=</span> <span class="n">epsilon</span> <span class="o">*</span> <span class="n">pert</span>
                <span class="n">flux_pert_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pert</span><span class="p">)</span>

            <span class="c1"># Take the dot-product with the exact adjoint computation</span>
            <span class="n">struct_loads_ajp</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">get_struct_loads_ajp</span><span class="p">(</span><span class="n">scenario</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">struct_loads_ajp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">adjoint_product</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">struct_loads_ajp</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">load_pert_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

            <span class="n">struct_flux_ajp</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">get_struct_heat_flux_ajp</span><span class="p">(</span><span class="n">scenario</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">struct_flux_ajp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">adjoint_product</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">struct_flux_ajp</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">flux_pert_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Sum up the result across all processors</span>
        <span class="n">adjoint_product</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="n">adjoint_product</span><span class="p">)</span>

        <span class="c1"># Run the perturbed aerodynamic simulation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iterate</span><span class="p">(</span><span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">)</span>

        <span class="c1"># Evaluate and store the functions of interest</span>
        <span class="n">fvals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_functions</span><span class="p">(</span><span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">scenario</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span>
            <span class="n">fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

        <span class="c1"># Compute the finite-difference approximation</span>
        <span class="k">if</span> <span class="n">complex_step</span><span class="p">:</span>
            <span class="n">fd_product</span> <span class="o">=</span> <span class="n">fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span> <span class="o">/</span> <span class="n">epsilon</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fd_product</span> <span class="o">=</span> <span class="p">(</span><span class="n">fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">fvals_init</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">epsilon</span>
        <span class="k">for</span> <span class="n">body</span> <span class="ow">in</span> <span class="n">bodies</span><span class="p">:</span>
            <span class="n">struct_disps</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">get_struct_disps</span><span class="p">(</span><span class="n">scenario</span><span class="p">)</span>
            <span class="n">struct_disps_ajp</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">get_struct_disps_ajp</span><span class="p">(</span><span class="n">scenario</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">struct_disps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">struct_disps_ajp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">struct_disps_copy</span> <span class="o">=</span> <span class="n">struct_disps_list</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">complex_step</span><span class="p">:</span>
                    <span class="n">fd</span> <span class="o">=</span> <span class="n">struct_disps</span><span class="o">.</span><span class="n">imag</span> <span class="o">/</span> <span class="n">epsilon</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fd</span> <span class="o">=</span> <span class="p">(</span><span class="n">struct_disps</span> <span class="o">-</span> <span class="n">struct_disps_copy</span><span class="p">)</span> <span class="o">/</span> <span class="n">epsilon</span>
                <span class="n">fd_product</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">struct_disps_ajp</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>

            <span class="n">struct_temps</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">get_struct_temps</span><span class="p">(</span><span class="n">scenario</span><span class="p">)</span>
            <span class="n">struct_temps_ajp</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">get_struct_temps_ajp</span><span class="p">(</span><span class="n">scenario</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">struct_temps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">struct_temps_ajp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">struct_temps_copy</span> <span class="o">=</span> <span class="n">struct_temps_list</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">complex_step</span><span class="p">:</span>
                    <span class="n">fd</span> <span class="o">=</span> <span class="n">struct_temps</span><span class="o">.</span><span class="n">imag</span> <span class="o">/</span> <span class="n">epsilon</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fd</span> <span class="o">=</span> <span class="p">(</span><span class="n">struct_temps</span> <span class="o">-</span> <span class="n">struct_temps_copy</span><span class="p">)</span> <span class="o">/</span> <span class="n">epsilon</span>
                <span class="n">fd_product</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">struct_temps_ajp</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Compute the finite-differenc approximation</span>
        <span class="n">fd_product</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="n">fd_product</span><span class="p">)</span>

        <span class="n">fail</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">rel_err</span> <span class="o">=</span> <span class="p">(</span><span class="n">adjoint_product</span> <span class="o">-</span> <span class="n">fd_product</span><span class="p">)</span> <span class="o">/</span> <span class="n">fd_product</span>
            <span class="n">fail</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">rel_err</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">rtol</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Structural solver adjoint result:           &quot;</span><span class="p">,</span> <span class="n">adjoint_product</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Structural solver finite-difference result: &quot;</span><span class="p">,</span> <span class="n">fd_product</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Structural solver relative error:           &quot;</span><span class="p">,</span> <span class="n">rel_err</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Structural solver fail flag:                &quot;</span><span class="p">,</span> <span class="n">fail</span><span class="p">)</span>

        <span class="n">fail</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">fail</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fail</span></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">FUNtoFEM .0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">pyfuntofem.interface._solver_interface</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021, FUNtoFEM Developers.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.0.2.
    </div>
  </body>
</html>