
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>solver_interface &#8212; FUNtoFEM .0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinxdoc.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">FUNtoFEM .0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">solver_interface</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for solver_interface</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>

<span class="c1"># This file is part of the package FUNtoFEM for coupled aeroelastic simulation</span>
<span class="c1"># and design optimization.</span>

<span class="c1"># Copyright (C) 2015 Georgia Tech Research Corporation.</span>
<span class="c1"># Additional copyright (C) 2015 Kevin Jacobson, Jan Kiviaho and Graeme Kennedy.</span>
<span class="c1"># All rights reserved.</span>

<span class="c1"># FUNtoFEM is licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this software except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>

<span class="c1">#   http://www.apache.org/licenses/LICENSE-2.0</span>

<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<div class="viewcode-block" id="SolverInterface"><a class="viewcode-back" href="../programmers_guide.html#solver_interface.SolverInterface">[docs]</a><span class="k">class</span> <span class="nc">SolverInterface</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A base class to define what functions solver interfaces in FUNtoFEM need</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The solver constructor is required to set discipline node locations (either :math:`x_a` or :math:`x_s`) in the funtofem body class as ``body.aero_X`` or ``body.struct_X``. The constructor can be used flexibly for other discipline solver specific activities (e.g. solver instantiation, reading mesh, allocating solver data).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Notional aerodynamic solver implementation ``solver``:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            # Set aerodynamic surface meshes</span>
<span class="sd">            for ibody, body in enumerate(bodies):</span>
<span class="sd">                body.aero_X = solver.get_mesh(ibody)</span>

<span class="sd">        Notional structural solver implementation ``solver``:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            # Set structural meshes</span>
<span class="sd">            for ibody, body in enumerate(bodies):</span>
<span class="sd">                body.struc_X = solver.get_mesh(ibody)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>







    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A base class to define what functions solver interfaces in FUNtoFEM need</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="SolverInterface.set_variables"><a class="viewcode-back" href="../programmers_guide.html#solver_interface.SolverInterface.set_variables">[docs]</a>    <span class="k">def</span> <span class="nf">set_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the design variables into the solver.</span>
<span class="sd">        The scenario and bodies objects have dictionaries of :class:`~variable.Variable` objects.</span>
<span class="sd">        The interface class should pick out which type of variables it needs and pass them into the solver</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scenario: :class:`~scenario.Scenario`</span>
<span class="sd">            The current scenario</span>
<span class="sd">        bodies: list of :class:`~body.Body` objects</span>
<span class="sd">            The bodies in the model</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Structural Solver:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">           for ibody,body in enumerate(bodies):</span>
<span class="sd">               if &#39;structural&#39; in body.variables:</span>
<span class="sd">                   for var in body.variables[&#39;structural&#39;]:</span>
<span class="sd">                       solver.set_body_variable(ibody, var.value)</span>

<span class="sd">        Aerodynamic Solver:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">           if &#39;aerodynamic&#39; in scenario.variables:</span>
<span class="sd">               for var in scenario.variables[&#39;aerodynamic&#39;]:</span>
<span class="sd">                   if var.active:</span>
<span class="sd">                       solver.set_body_variable(var.name, var.value)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="SolverInterface.set_functions"><a class="viewcode-back" href="../programmers_guide.html#solver_interface.SolverInterface.set_functions">[docs]</a>    <span class="k">def</span> <span class="nf">set_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the function definitions into the solver.</span>
<span class="sd">        The scenario has a list of function objects.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scenario: :class:`~scenario.Scenario`</span>
<span class="sd">            The current scenario</span>
<span class="sd">        bodies: list of :class:`~body.Body` objects</span>
<span class="sd">            The bodies in the model</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Structural Solver:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">           for func in scenario.functions:</span>

<span class="sd">               # Set the structural functions in</span>
<span class="sd">               if function.adjoint and function.analysis_type==&#39;structural&#39;:</span>
<span class="sd">                   solver.set_adjoint_function(function.name, function.start, function,stop)</span>

<span class="sd">               # Tell the solver that an adjoint is needed, but the function is not explicitly dependent on structural states</span>
<span class="sd">               elif function.adjoint and function.analysis_type !=&#39;structural&#39;:</span>
<span class="sd">                   solver.set_dummy_function()</span>

<span class="sd">               # Functions such as structural mass do not need and adjoint</span>
<span class="sd">               elif not function.adjoint and function.analysis_type==&#39;structural&#39;:</span>
<span class="sd">                   solver.set_nonadjoint_function(function.name)</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="SolverInterface.get_functions"><a class="viewcode-back" href="../programmers_guide.html#solver_interface.SolverInterface.get_functions">[docs]</a>    <span class="k">def</span> <span class="nf">get_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Put the function values from the solver in the value attribute of the scneario&#39;s functions.</span>
<span class="sd">        The scenario has the list of function objects where the function&#39;s owned by this solver will be set.</span>
<span class="sd">        You can evaluate the functions based on the name or based on the functions set during :func:`~solver_interface.SolverInterface.set_functions`.</span>
<span class="sd">        The solver is only responsible for returning the values of functions it owns.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scenario: :class:`~scenario.Scenario`</span>
<span class="sd">            The current scenario</span>
<span class="sd">        bodies: list of :class:`~body.Body` objects</span>
<span class="sd">            The bodies in the model</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Structural Solver:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">           for func in scenario.functions:</span>

<span class="sd">               # Set the structural functions in</span>
<span class="sd">               if function.analysis_type==&#39;structural&#39;:</span>
<span class="sd">                   if function.name == &#39;mass&#39;:</span>
<span class="sd">                       function.value = solver.evaluate_mass()</span>
<span class="sd">                   elif function.name == &#39;ksfailure&#39;:</span>
<span class="sd">                       function.value = solver.get_ksfailure()</span>
<span class="sd">                   elif function.name == &#39;ksfailure&#39;:</span>
<span class="sd">                       function.value = solver.get_ksfailure()</span>
<span class="sd">                   else function.name == &#39;ksfailure&#39;:</span>
<span class="sd">                       print(&quot;Unknown structural function in get_functions&quot;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="SolverInterface.get_function_gradients"><a class="viewcode-back" href="../programmers_guide.html#solver_interface.SolverInterface.get_function_gradients">[docs]</a>    <span class="k">def</span> <span class="nf">get_function_gradients</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the derivatives of all the functions with respect to design variables associated with this solver.</span>
<span class="sd">        The derivatives in the scenario and body objects are a Python dictionary where the keys are the type of variable.</span>
<span class="sd">        Each entry in the dictionary a list where each entry is associated with a function in the model. Finally, there is a list where each index is associated with a particular design variable.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scenario: :class:`~scenario.Scenario`</span>
<span class="sd">            The current scenario</span>
<span class="sd">        bodies: list of :class:`~body.Body` objects</span>
<span class="sd">            The bodies in the model</span>
<span class="sd">        offset: int</span>
<span class="sd">            offset of the scenario&#39;s function index w.r.t the full list of functions in the model.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Aerodynamic Solver:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            for func, function in enumerate(scenario.functions):</span>
<span class="sd">                for vartype in scenario.variables:</span>
<span class="sd">                    if vartype == &#39;aerodynamic&#39;:</span>
<span class="sd">                        for i, var in enumerate(scenario.variables[vartype]):</span>
<span class="sd">                            if var.active:</span>
<span class="sd">                                scenario.derivatives[vartype][offset+func][i] = solver.get_derivative(function.id,var.id)</span>

<span class="sd">        Structural Solver:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            for func, function in enumerate(scenario.functions):</span>
<span class="sd">                for ibody, body in enumerate(bodies):</span>
<span class="sd">                    for vartype in body.variables:</span>
<span class="sd">                        if vartype == &#39;structural&#39;:</span>
<span class="sd">                            for i, var in enumerate(body.variables[vartype]):</span>
<span class="sd">                                if var.active:</span>
<span class="sd">                                    body.derivatives[vartype][offset+func][i] = solver.get_derivative(func,ibody,i)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="SolverInterface.get_coordinate_derivatives"><a class="viewcode-back" href="../programmers_guide.html#solver_interface.SolverInterface.get_coordinate_derivatives">[docs]</a>    <span class="k">def</span> <span class="nf">get_coordinate_derivatives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add the solver&#39;s contributions to the coordinate derivatives for this time step or the total value for the steady case.</span>
<span class="sd">        The coordinate derivatives are stored in the body objects in the aero_shape_term and struct_shape_term attributes.</span>

<span class="sd">        For time dependent problems, this is called at the end of every time step during reverse marching.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scenario: :class:`~scenario.Scenario`</span>
<span class="sd">            The current scenario</span>
<span class="sd">        bodies: list of :class:`~body.Body` objects</span>
<span class="sd">            The bodies in the model</span>
<span class="sd">        step: int</span>
<span class="sd">            The time step number</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Aerodynamic Solver:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            nfunctions = scenario.count_adjoint_functions()</span>
<span class="sd">            for ibody, body in enumerate(bodies):</span>
<span class="sd">                if body.shape and body.aero_nnodes &gt; 0:</span>

<span class="sd">                    lam_x, lam_y, lam_Z = solver.extract_coordinate_derivatives(step)</span>

<span class="sd">                    # Add (don&#39;t overwrite) the solver&#39;s contribution</span>
<span class="sd">                    body.aero_shape_term[ ::3,:nfunctions] += lam_x[:,:]</span>
<span class="sd">                    body.aero_shape_term[1::3,:nfunctions] += lam_y[:,:]</span>
<span class="sd">                    body.aero_shape_term[2::3,:nfunctions] += lam_z[:,:]</span>

<span class="sd">        Structural Solver:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            for ibody, body in enumerate(bodies):</span>
<span class="sd">                if body.shape:</span>

<span class="sd">                    lam_x, lam_y, lam_Z = solver.extract_coordinate_derivatives(step)</span>

<span class="sd">                    # Add (don&#39;t overwrite) the solver&#39;s contribution</span>
<span class="sd">                    body.struct_shape_term[ ::3,:nfunctions] += lam_x[:,:]</span>
<span class="sd">                    body.struct_shape_term[1::3,:nfunctions] += lam_y[:,:]</span>
<span class="sd">                    body.struct_shape_term[2::3,:nfunctions] += lam_z[:,:]</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="SolverInterface.initialize"><a class="viewcode-back" href="../programmers_guide.html#solver_interface.SolverInterface.initialize">[docs]</a>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set up anything that is necessary for a specific scenario prior to calls to ``iterate``. A requirement is that discipline solvers update their mesh representations to be consistent with ``body.aero_X`` (:math:`x_a`) or ``body.struct_X`` (:math:`x_s`) respectively due to fact that they may have been updated as a result of design changes.</span>

<span class="sd">        Note, it is possible that a discipline solver mesh representation is updated by reading a mesh file instead of accepting the funtofem body representation. Ultimately, the requirement is that the funtofem body mesh representations ``body.aero_X`` and ``body.struct_X`` and their corresponding discipline solver mesh representations are consistent.</span>

<span class="sd">        The initialize step may accomodate other useful activities such as data allocation, setting initial conditions, etc.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scenario: :class:`~scenario.Scenario`</span>
<span class="sd">            The current scenario</span>
<span class="sd">        bodies: list of :class:`~body.Body` objects</span>
<span class="sd">            The bodies in the model</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Aerodynamic Solver:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            # Set in the new aerodynamic surface meshes</span>
<span class="sd">            for ibody, body in enumerate(bodies):</span>
<span class="sd">                solver.set_surface_mesh(ibody, body.aero_X)</span>

<span class="sd">           # Initialize the flow field</span>
<span class="sd">           solver.initialize()</span>

<span class="sd">        Structural Solver:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            # Set the new structural surface mesh</span>
<span class="sd">            for ibody, body in enumerate(bodies):</span>
<span class="sd">                solver.set_mesh(ibody, body.struct_X)</span>

<span class="sd">           # Initialize the flow field</span>
<span class="sd">           solver.initialize()</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="SolverInterface.iterate"><a class="viewcode-back" href="../programmers_guide.html#solver_interface.SolverInterface.iterate">[docs]</a>    <span class="k">def</span> <span class="nf">iterate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate on the primal residual equation for the present discipline solver. Called in NLBGS solver.</span>

<span class="sd">        For an aerodynamic solver, this might include:</span>

<span class="sd">        #. Obtain displacements at aerodynamic surface nodes :math:`u_a` from funtofem body objects ``body.aero_disps``</span>
<span class="sd">        #. Deform the meshes</span>
<span class="sd">        #. Solve for the new aerodynamic state :math:`q`</span>
<span class="sd">        #. Integrate and localize aerodynamic surface forces :math:`f_a` at aerodynamic surface node locations and set in the funtofem body object ``body.aero_loads``</span>

<span class="sd">        For a structural solver: </span>

<span class="sd">        #. Obtain the forces at structural nodes :math:`f_s` from funtofem body objects ``body.struct_loads``</span>
<span class="sd">        #. Solve for new displacement state :math:`u_s`</span>
<span class="sd">        #. Set new structural displacements :math:`u_s` in the body objects ``body.struct_disps``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scenario: :class:`~scenario.Scenario`</span>
<span class="sd">            The current scenario</span>
<span class="sd">        bodies: list of :class:`~body.Body` objects</span>
<span class="sd">            The bodies in the model</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Aerodynamic Solver:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            # Input the surface deflections</span>
<span class="sd">            for ibody, body in enumerate(bodies):</span>
<span class="sd">                if body.aero_nnodes &gt; 0:</span>
<span class="sd">                    solver.input_surface_deformation(ibody, body.aero_disps)</span>

<span class="sd">            # Advance the solver</span>
<span class="sd">            solver.iterate()</span>

<span class="sd">            # Extract the surface forces</span>
<span class="sd">            for ibody, body in enumerate(bodies):</span>
<span class="sd">                if body.aero_nnodes &gt; 0:</span>
<span class="sd">                    body.aero_loads = solver.extract_forces(ibody)</span>

<span class="sd">        Structural Solver:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            # Input the forces on the structure</span>
<span class="sd">            for ibody, body in enumerate(bodies):</span>
<span class="sd">                if body.aero_nnodes &gt; 0:</span>
<span class="sd">                    solver.input_forces(ibody, body.struct_loads)</span>

<span class="sd">            # Advance the solver</span>
<span class="sd">            solver.iterate()</span>

<span class="sd">            # Extract the displacemets</span>
<span class="sd">            for ibody, body in enumerate(bodies):</span>
<span class="sd">                if body.aero_nnodes &gt; 0:</span>
<span class="sd">                    body.struct_disps = solver.extract_displacements(ibody)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="SolverInterface.post"><a class="viewcode-back" href="../programmers_guide.html#solver_interface.SolverInterface.post">[docs]</a>    <span class="k">def</span> <span class="nf">post</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform any tasks the solver needs to do after the forward steps are complete, e.g., evaluate functions, post-process, deallocate unneeded memory.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scenario: :class:`~scenario.Scenario`</span>
<span class="sd">            The current scenario</span>
<span class="sd">        bodies: list of :class:`~body.Body` objects</span>
<span class="sd">            The bodies in the model</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="SolverInterface.initialize_adjoint"><a class="viewcode-back" href="../programmers_guide.html#solver_interface.SolverInterface.initialize_adjoint">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform any tasks the solver needs to do before taking adjoint steps</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scenario: :class:`~scenario.Scenario`</span>
<span class="sd">            The current scenario</span>
<span class="sd">        bodies: list of :class:`~body.Body` objects</span>
<span class="sd">            The bodies in the model</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="SolverInterface.set_states"><a class="viewcode-back" href="../programmers_guide.html#solver_interface.SolverInterface.set_states">[docs]</a>    <span class="k">def</span> <span class="nf">set_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load the states (aero_loads, struct_disps) associated with this step either from memory or the disk for the transfer scheme to linearize about.</span>
<span class="sd">        This function is called at the beginning of each adjoint step in time dependent problems.</span>


<span class="sd">        **Note: in the NLBGS algorithm the transfer scheme uses the structural displacements from the prior step. set_states will request the states from the previous step but then ask the structural solver to linearize about the current step in iterate_adjoint**</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scenario: :class:`~scenario.Scenario`</span>
<span class="sd">            The current scenario</span>
<span class="sd">        bodies: list of :class:`~body.Body` objects</span>
<span class="sd">            The bodies in the model</span>
<span class="sd">        step: int</span>
<span class="sd">            The time step number that the driver wants the states from</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Structural Solver:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            # Find the step&#39;s values on the disk</span>
<span class="sd">            disps_hist = solver.load_state(step)</span>

<span class="sd">            # Set the structural displacements for the transfer scheme residuals to linearize about</span>
<span class="sd">            for ibody,body in enumerate(bodies):</span>
<span class="sd">                body.struct_disps = disps_hist[ibody]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="SolverInterface.iterate_adjoint"><a class="viewcode-back" href="../programmers_guide.html#solver_interface.SolverInterface.iterate_adjoint">[docs]</a>    <span class="k">def</span> <span class="nf">iterate_adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adjoint iteration for the solver. Typical involves the solver reading in a RHS term then returning an adjoint or adjoint-product.</span>
<span class="sd">        Called in NLBGS solver.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scenario: :class:`~scenario.Scenario`</span>
<span class="sd">            The current scenario</span>
<span class="sd">        bodies: list of :class:`~body.Body` objects</span>
<span class="sd">            The bodies in the model</span>
<span class="sd">        step: int</span>
<span class="sd">            The step number. Will start at the final step and march backwards to 0, the initial condition.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Aerodynamic Solver:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            # Read in the force adjoint</span>
<span class="sd">            for ibody, body in enumerate(bodies):</span>
<span class="sd">                solver.set_force_adjoint(body.psi_F)</span>

<span class="sd">                # take a reverse step in the adjoint solver</span>
<span class="sd">                solver.iterate_adjoint(step)</span>

<span class="sd">                # pull out the grid adjoint value</span>
<span class="sd">                for ibody, body in enumerate(bodies):</span>
<span class="sd">                    psi_G = solver.get_grid_adjoint(ibody)</span>

<span class="sd">                    # &#39;solve&#39; for the displacement adjoint</span>
<span class="sd">                    body.psi_D = -psi_G</span>


<span class="sd">        Structural Solver:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            # put the body RHS&#39;s into the solver bvec</span>
<span class="sd">            for ibody, body in enumerate(bodies):</span>
<span class="sd">                solver.add_body_rhs_term(ibody, body.struct_rhs)</span>

<span class="sd">            # take a reverse step in the adjoint solver</span>
<span class="sd">            solver.iterate_adjoint(step)</span>

<span class="sd">            # pull out the structural adjoint value</span>
<span class="sd">            for ibody, body in enumerate(bodies):</span>
<span class="sd">                body.psi_S = solver.get_struct_adjoint(ibody)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="SolverInterface.post_adjoint"><a class="viewcode-back" href="../programmers_guide.html#solver_interface.SolverInterface.post_adjoint">[docs]</a>    <span class="k">def</span> <span class="nf">post_adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Any actions that need to be performed after completing the adjoint solve, e.g., evaluating gradients, deallocating memory, etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="SolverInterface.step_pre"><a class="viewcode-back" href="../programmers_guide.html#solver_interface.SolverInterface.step_pre">[docs]</a>    <span class="k">def</span> <span class="nf">step_pre</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Operations before at a step in an FSI subiteration case.</span>
<span class="sd">        Called in NLBGS with FSI subiterations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scenario: :class:`~scenario.Scenario`</span>
<span class="sd">            The current scenario</span>
<span class="sd">        bodies: list of :class:`~body.Body` objects</span>
<span class="sd">            The bodies in the model</span>
<span class="sd">        step: int</span>
<span class="sd">            The step number. Will start at the final step and march backwards to 0, the initial condition.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="SolverInterface.step_solver"><a class="viewcode-back" href="../programmers_guide.html#solver_interface.SolverInterface.step_solver">[docs]</a>    <span class="k">def</span> <span class="nf">step_solver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">fsi_subiter</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Step in an FSI subiteration case.</span>
<span class="sd">        Called in NLBGS with FSI subiterations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scenario: :class:`~scenario.Scenario`</span>
<span class="sd">            The current scenario</span>
<span class="sd">        bodies: list of :class:`~body.Body` objects</span>
<span class="sd">            The bodies in the model</span>
<span class="sd">        step: int</span>
<span class="sd">            The step number. Will start at the final step and march backwards to 0, the initial condition.</span>
<span class="sd">        fsi_subiter: int</span>
<span class="sd">            The FSI subiteration number</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="SolverInterface.step_post"><a class="viewcode-back" href="../programmers_guide.html#solver_interface.SolverInterface.step_post">[docs]</a>    <span class="k">def</span> <span class="nf">step_post</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scenario</span><span class="p">,</span> <span class="n">bodies</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Operations after at a step in an FSI subiteration case.</span>
<span class="sd">        Called in NLBGS with FSI subiterations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scenario: :class:`~scenario.Scenario`</span>
<span class="sd">            The current scenario</span>
<span class="sd">        bodies: list of :class:`~body.Body` objects</span>
<span class="sd">            The bodies in the model</span>
<span class="sd">        step: int</span>
<span class="sd">            The step number. Will start at the final step and march backwards to 0, the initial condition.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">0</span></div></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">FUNtoFEM .0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">solver_interface</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021, FUNtoFEM Developers.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.0.2.
    </div>
  </body>
</html>