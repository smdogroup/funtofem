
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Programmer’s Guide &#8212; FUNtoFEM .0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinxdoc.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="pyFUNtoFEM" href="py_script.html" />
    <link rel="prev" title="Transfer Scheme" href="transfer_scheme.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="py_script.html" title="pyFUNtoFEM"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="transfer_scheme.html" title="Transfer Scheme"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">FUNtoFEM .0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Programmer’s Guide</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="programmer-s-guide">
<h1>Programmer’s Guide<a class="headerlink" href="#programmer-s-guide" title="Permalink to this heading">¶</a></h1>
<p>This section explains how to add your solver, shape parameterization, algorithm to the FUNtoFEM framework.
It will be helpful to be familiar with the existing driver and model classes before attempting to add or modify the framework.</p>
<p>Any add new variables you add to the body and scenario classes will be accessible to any of the solvers, so if you need to exchange or just store data, this is a good place to do it.</p>
<section id="create-an-interface-class-for-a-solver">
<h2>Create an interface class for a solver<a class="headerlink" href="#create-an-interface-class-for-a-solver" title="Permalink to this heading">¶</a></h2>
<p>The interface class for the solver allows the FUNtoFEM driver to instruct the solver to perform tasks like iterate and has some setters and getters to exchange data.
The setters and getters are written from the perspective of FUNtoFEM, i.e., the direction of the setters and getters is such that the setters put data from FUNtoFEM into the solver and the getters retrieve data from the solver to be used in FUNtoFEM.
If your solver does not need a particular method described below, leaving it as a <em>pass</em> as in the base class is acceptable.</p>
<p>The file solver_interface.py contains the base interface class which has the routines necessary for using the nonlinear block Gauss Seidel solver.
All of the methods in this class (except set_mesh) have the current scenario and the list of bodies as inputs.
These objects contain the coupling input data for the solver and are where the solver interface needs to set the coupling output.</p>
<section id="data-to-be-set-during-initialization">
<h3>Data to be set during initialization<a class="headerlink" href="#data-to-be-set-during-initialization" title="Permalink to this heading">¶</a></h3>
<p>Before instantiating the driver, the <code class="xref py py-class docutils literal notranslate"><span class="pre">Body</span></code> objects need to contain some information about the meshes.
It is recommended to do this during the instantiation of the solvers in the solver dictionary.
For an aerodynamic solver, the <code class="xref py py-class docutils literal notranslate"><span class="pre">Body</span></code> holds the surface mesh and number of nodes on the processor: body.aero_X and body.aero_nnodes.
aero_X is a flattened array of length 3*aero_nnodes.
For a structural solver, the <code class="xref py py-class docutils literal notranslate"><span class="pre">Body</span></code> holds the entire structural mesh and number of nodes: body.struct_X and body.struct_nnodes.
struct_X is a flattened array of length 3*struct_nnodes.</p>
</section>
<section id="module-solver_interface">
<span id="solver-interface-class"></span><h3>Solver Interface Class<a class="headerlink" href="#module-solver_interface" title="Permalink to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="solver_interface.SolverInterface">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">solver_interface.</span></span><span class="sig-name descname"><span class="pre">SolverInterface</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/solver_interface.html#SolverInterface"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#solver_interface.SolverInterface" title="Permalink to this definition">¶</a></dt>
<dd><p>A base class to define what functions solver interfaces in FUNtoFEM need</p>
<p>The solver constructor is required to set discipline node locations (either <span class="math notranslate nohighlight">\(x_a\)</span> or <span class="math notranslate nohighlight">\(x_s\)</span>) in the funtofem body class as <code class="docutils literal notranslate"><span class="pre">body.aero_X</span></code> or <code class="docutils literal notranslate"><span class="pre">body.struct_X</span></code>. The constructor can be used flexibly for other discipline solver specific activities (e.g. solver instantiation, reading mesh, allocating solver data).</p>
<p class="rubric">Examples</p>
<p>Notional aerodynamic solver implementation <code class="docutils literal notranslate"><span class="pre">solver</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set aerodynamic surface meshes</span>
<span class="k">for</span> <span class="n">ibody</span><span class="p">,</span> <span class="n">body</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bodies</span><span class="p">):</span>
    <span class="n">body</span><span class="o">.</span><span class="n">aero_X</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">get_mesh</span><span class="p">(</span><span class="n">ibody</span><span class="p">)</span>
</pre></div>
</div>
<p>Notional structural solver implementation <code class="docutils literal notranslate"><span class="pre">solver</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set structural meshes</span>
<span class="k">for</span> <span class="n">ibody</span><span class="p">,</span> <span class="n">body</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bodies</span><span class="p">):</span>
    <span class="n">body</span><span class="o">.</span><span class="n">struc_X</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">get_mesh</span><span class="p">(</span><span class="n">ibody</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="solver_interface.SolverInterface.set_variables">
<span class="sig-name descname"><span class="pre">set_variables</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scenario</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bodies</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/solver_interface.html#SolverInterface.set_variables"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#solver_interface.SolverInterface.set_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the design variables into the solver.
The scenario and bodies objects have dictionaries of <a class="reference internal" href="model.html#variable.Variable" title="variable.Variable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a> objects.
The interface class should pick out which type of variables it needs and pass them into the solver</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scenario</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Scenario</span></code>) – The current scenario</p></li>
<li><p><strong>bodies</strong> (list of <code class="xref py py-class docutils literal notranslate"><span class="pre">Body</span></code> objects) – The bodies in the model</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Structural Solver:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">ibody</span><span class="p">,</span><span class="n">body</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bodies</span><span class="p">):</span>
    <span class="k">if</span> <span class="s1">&#39;structural&#39;</span> <span class="ow">in</span> <span class="n">body</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">body</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s1">&#39;structural&#39;</span><span class="p">]:</span>
            <span class="n">solver</span><span class="o">.</span><span class="n">set_body_variable</span><span class="p">(</span><span class="n">ibody</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<p>Aerodynamic Solver:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="s1">&#39;aerodynamic&#39;</span> <span class="ow">in</span> <span class="n">scenario</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">scenario</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s1">&#39;aerodynamic&#39;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">active</span><span class="p">:</span>
            <span class="n">solver</span><span class="o">.</span><span class="n">set_body_variable</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solver_interface.SolverInterface.set_functions">
<span class="sig-name descname"><span class="pre">set_functions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scenario</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bodies</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/solver_interface.html#SolverInterface.set_functions"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#solver_interface.SolverInterface.set_functions" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the function definitions into the solver.
The scenario has a list of function objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scenario</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Scenario</span></code>) – The current scenario</p></li>
<li><p><strong>bodies</strong> (list of <code class="xref py py-class docutils literal notranslate"><span class="pre">Body</span></code> objects) – The bodies in the model</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Structural Solver:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">scenario</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span>

    <span class="c1"># Set the structural functions in</span>
    <span class="k">if</span> <span class="n">function</span><span class="o">.</span><span class="n">adjoint</span> <span class="ow">and</span> <span class="n">function</span><span class="o">.</span><span class="n">analysis_type</span><span class="o">==</span><span class="s1">&#39;structural&#39;</span><span class="p">:</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">set_adjoint_function</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">function</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span><span class="n">stop</span><span class="p">)</span>

    <span class="c1"># Tell the solver that an adjoint is needed, but the function is not explicitly dependent on structural states</span>
    <span class="k">elif</span> <span class="n">function</span><span class="o">.</span><span class="n">adjoint</span> <span class="ow">and</span> <span class="n">function</span><span class="o">.</span><span class="n">analysis_type</span> <span class="o">!=</span><span class="s1">&#39;structural&#39;</span><span class="p">:</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">set_dummy_function</span><span class="p">()</span>

    <span class="c1"># Functions such as structural mass do not need and adjoint</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">function</span><span class="o">.</span><span class="n">adjoint</span> <span class="ow">and</span> <span class="n">function</span><span class="o">.</span><span class="n">analysis_type</span><span class="o">==</span><span class="s1">&#39;structural&#39;</span><span class="p">:</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">set_nonadjoint_function</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solver_interface.SolverInterface.get_functions">
<span class="sig-name descname"><span class="pre">get_functions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scenario</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bodies</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/solver_interface.html#SolverInterface.get_functions"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#solver_interface.SolverInterface.get_functions" title="Permalink to this definition">¶</a></dt>
<dd><p>Put the function values from the solver in the value attribute of the scneario’s functions.
The scenario has the list of function objects where the function’s owned by this solver will be set.
You can evaluate the functions based on the name or based on the functions set during <a class="reference internal" href="#solver_interface.SolverInterface.set_functions" title="solver_interface.SolverInterface.set_functions"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_functions()</span></code></a>.
The solver is only responsible for returning the values of functions it owns.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scenario</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Scenario</span></code>) – The current scenario</p></li>
<li><p><strong>bodies</strong> (list of <code class="xref py py-class docutils literal notranslate"><span class="pre">Body</span></code> objects) – The bodies in the model</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Structural Solver:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">scenario</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span>

    <span class="c1"># Set the structural functions in</span>
    <span class="k">if</span> <span class="n">function</span><span class="o">.</span><span class="n">analysis_type</span><span class="o">==</span><span class="s1">&#39;structural&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">function</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;mass&#39;</span><span class="p">:</span>
            <span class="n">function</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">evaluate_mass</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">function</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;ksfailure&#39;</span><span class="p">:</span>
            <span class="n">function</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">get_ksfailure</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">function</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;ksfailure&#39;</span><span class="p">:</span>
            <span class="n">function</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">get_ksfailure</span><span class="p">()</span>
        <span class="k">else</span> <span class="n">function</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;ksfailure&#39;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Unknown structural function in get_functions&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solver_interface.SolverInterface.get_function_gradients">
<span class="sig-name descname"><span class="pre">get_function_gradients</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scenario</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bodies</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/solver_interface.html#SolverInterface.get_function_gradients"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#solver_interface.SolverInterface.get_function_gradients" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the derivatives of all the functions with respect to design variables associated with this solver.
The derivatives in the scenario and body objects are a Python dictionary where the keys are the type of variable.
Each entry in the dictionary a list where each entry is associated with a function in the model. Finally, there is a list where each index is associated with a particular design variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scenario</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Scenario</span></code>) – The current scenario</p></li>
<li><p><strong>bodies</strong> (list of <code class="xref py py-class docutils literal notranslate"><span class="pre">Body</span></code> objects) – The bodies in the model</p></li>
<li><p><strong>offset</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a>) – offset of the scenario’s function index w.r.t the full list of functions in the model.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Aerodynamic Solver:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">func</span><span class="p">,</span> <span class="n">function</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">scenario</span><span class="o">.</span><span class="n">functions</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">vartype</span> <span class="ow">in</span> <span class="n">scenario</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">vartype</span> <span class="o">==</span> <span class="s1">&#39;aerodynamic&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">scenario</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">vartype</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">active</span><span class="p">:</span>
                    <span class="n">scenario</span><span class="o">.</span><span class="n">derivatives</span><span class="p">[</span><span class="n">vartype</span><span class="p">][</span><span class="n">offset</span><span class="o">+</span><span class="n">func</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">get_derivative</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">id</span><span class="p">,</span><span class="n">var</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
</pre></div>
</div>
<p>Structural Solver:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">func</span><span class="p">,</span> <span class="n">function</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">scenario</span><span class="o">.</span><span class="n">functions</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">ibody</span><span class="p">,</span> <span class="n">body</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bodies</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">vartype</span> <span class="ow">in</span> <span class="n">body</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">vartype</span> <span class="o">==</span> <span class="s1">&#39;structural&#39;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">vartype</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">active</span><span class="p">:</span>
                        <span class="n">body</span><span class="o">.</span><span class="n">derivatives</span><span class="p">[</span><span class="n">vartype</span><span class="p">][</span><span class="n">offset</span><span class="o">+</span><span class="n">func</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">get_derivative</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="n">ibody</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solver_interface.SolverInterface.get_coordinate_derivatives">
<span class="sig-name descname"><span class="pre">get_coordinate_derivatives</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scenario</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bodies</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/solver_interface.html#SolverInterface.get_coordinate_derivatives"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#solver_interface.SolverInterface.get_coordinate_derivatives" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the solver’s contributions to the coordinate derivatives for this time step or the total value for the steady case.
The coordinate derivatives are stored in the body objects in the aero_shape_term and struct_shape_term attributes.</p>
<p>For time dependent problems, this is called at the end of every time step during reverse marching.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scenario</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Scenario</span></code>) – The current scenario</p></li>
<li><p><strong>bodies</strong> (list of <code class="xref py py-class docutils literal notranslate"><span class="pre">Body</span></code> objects) – The bodies in the model</p></li>
<li><p><strong>step</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a>) – The time step number</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Aerodynamic Solver:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">nfunctions</span> <span class="o">=</span> <span class="n">scenario</span><span class="o">.</span><span class="n">count_adjoint_functions</span><span class="p">()</span>
<span class="k">for</span> <span class="n">ibody</span><span class="p">,</span> <span class="n">body</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bodies</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">body</span><span class="o">.</span><span class="n">shape</span> <span class="ow">and</span> <span class="n">body</span><span class="o">.</span><span class="n">aero_nnodes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

        <span class="n">lam_x</span><span class="p">,</span> <span class="n">lam_y</span><span class="p">,</span> <span class="n">lam_Z</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">extract_coordinate_derivatives</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>

        <span class="c1"># Add (don&#39;t overwrite) the solver&#39;s contribution</span>
        <span class="n">body</span><span class="o">.</span><span class="n">aero_shape_term</span><span class="p">[</span> <span class="p">::</span><span class="mi">3</span><span class="p">,:</span><span class="n">nfunctions</span><span class="p">]</span> <span class="o">+=</span> <span class="n">lam_x</span><span class="p">[:,:]</span>
        <span class="n">body</span><span class="o">.</span><span class="n">aero_shape_term</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">3</span><span class="p">,:</span><span class="n">nfunctions</span><span class="p">]</span> <span class="o">+=</span> <span class="n">lam_y</span><span class="p">[:,:]</span>
        <span class="n">body</span><span class="o">.</span><span class="n">aero_shape_term</span><span class="p">[</span><span class="mi">2</span><span class="p">::</span><span class="mi">3</span><span class="p">,:</span><span class="n">nfunctions</span><span class="p">]</span> <span class="o">+=</span> <span class="n">lam_z</span><span class="p">[:,:]</span>
</pre></div>
</div>
<p>Structural Solver:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">ibody</span><span class="p">,</span> <span class="n">body</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bodies</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">body</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>

        <span class="n">lam_x</span><span class="p">,</span> <span class="n">lam_y</span><span class="p">,</span> <span class="n">lam_Z</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">extract_coordinate_derivatives</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>

        <span class="c1"># Add (don&#39;t overwrite) the solver&#39;s contribution</span>
        <span class="n">body</span><span class="o">.</span><span class="n">struct_shape_term</span><span class="p">[</span> <span class="p">::</span><span class="mi">3</span><span class="p">,:</span><span class="n">nfunctions</span><span class="p">]</span> <span class="o">+=</span> <span class="n">lam_x</span><span class="p">[:,:]</span>
        <span class="n">body</span><span class="o">.</span><span class="n">struct_shape_term</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">3</span><span class="p">,:</span><span class="n">nfunctions</span><span class="p">]</span> <span class="o">+=</span> <span class="n">lam_y</span><span class="p">[:,:]</span>
        <span class="n">body</span><span class="o">.</span><span class="n">struct_shape_term</span><span class="p">[</span><span class="mi">2</span><span class="p">::</span><span class="mi">3</span><span class="p">,:</span><span class="n">nfunctions</span><span class="p">]</span> <span class="o">+=</span> <span class="n">lam_z</span><span class="p">[:,:]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solver_interface.SolverInterface.initialize">
<span class="sig-name descname"><span class="pre">initialize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scenario</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bodies</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/solver_interface.html#SolverInterface.initialize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#solver_interface.SolverInterface.initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Set up anything that is necessary for a specific scenario prior to calls to <code class="docutils literal notranslate"><span class="pre">iterate</span></code>. A requirement is that discipline solvers update their mesh representations to be consistent with <code class="docutils literal notranslate"><span class="pre">body.aero_X</span></code> (<span class="math notranslate nohighlight">\(x_a\)</span>) or <code class="docutils literal notranslate"><span class="pre">body.struct_X</span></code> (<span class="math notranslate nohighlight">\(x_s\)</span>) respectively due to fact that they may have been updated as a result of design changes.</p>
<p>Note, it is possible that a discipline solver mesh representation is updated by reading a mesh file instead of accepting the funtofem body representation. Ultimately, the requirement is that the funtofem body mesh representations <code class="docutils literal notranslate"><span class="pre">body.aero_X</span></code> and <code class="docutils literal notranslate"><span class="pre">body.struct_X</span></code> and their corresponding discipline solver mesh representations are consistent.</p>
<p>The initialize step may accomodate other useful activities such as data allocation, setting initial conditions, etc.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scenario</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Scenario</span></code>) – The current scenario</p></li>
<li><p><strong>bodies</strong> (list of <code class="xref py py-class docutils literal notranslate"><span class="pre">Body</span></code> objects) – The bodies in the model</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Aerodynamic Solver:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span> <span class="c1"># Set in the new aerodynamic surface meshes</span>
 <span class="k">for</span> <span class="n">ibody</span><span class="p">,</span> <span class="n">body</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bodies</span><span class="p">):</span>
     <span class="n">solver</span><span class="o">.</span><span class="n">set_surface_mesh</span><span class="p">(</span><span class="n">ibody</span><span class="p">,</span> <span class="n">body</span><span class="o">.</span><span class="n">aero_X</span><span class="p">)</span>

<span class="c1"># Initialize the flow field</span>
<span class="n">solver</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>
</pre></div>
</div>
<p>Structural Solver:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span> <span class="c1"># Set the new structural surface mesh</span>
 <span class="k">for</span> <span class="n">ibody</span><span class="p">,</span> <span class="n">body</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bodies</span><span class="p">):</span>
     <span class="n">solver</span><span class="o">.</span><span class="n">set_mesh</span><span class="p">(</span><span class="n">ibody</span><span class="p">,</span> <span class="n">body</span><span class="o">.</span><span class="n">struct_X</span><span class="p">)</span>

<span class="c1"># Initialize the flow field</span>
<span class="n">solver</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solver_interface.SolverInterface.iterate">
<span class="sig-name descname"><span class="pre">iterate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scenario</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bodies</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/solver_interface.html#SolverInterface.iterate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#solver_interface.SolverInterface.iterate" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate on the primal residual equation for the present discipline solver. Called in NLBGS solver.</p>
<p>For an aerodynamic solver, this might include:</p>
<ol class="arabic simple">
<li><p>Obtain displacements at aerodynamic surface nodes <span class="math notranslate nohighlight">\(u_a\)</span> from funtofem body objects <code class="docutils literal notranslate"><span class="pre">body.aero_disps</span></code></p></li>
<li><p>Deform the meshes</p></li>
<li><p>Solve for the new aerodynamic state <span class="math notranslate nohighlight">\(q\)</span></p></li>
<li><p>Integrate and localize aerodynamic surface forces <span class="math notranslate nohighlight">\(f_a\)</span> at aerodynamic surface node locations and set in the funtofem body object <code class="docutils literal notranslate"><span class="pre">body.aero_loads</span></code></p></li>
</ol>
<p>For a structural solver:</p>
<ol class="arabic simple">
<li><p>Obtain the forces at structural nodes <span class="math notranslate nohighlight">\(f_s\)</span> from funtofem body objects <code class="docutils literal notranslate"><span class="pre">body.struct_loads</span></code></p></li>
<li><p>Solve for new displacement state <span class="math notranslate nohighlight">\(u_s\)</span></p></li>
<li><p>Set new structural displacements <span class="math notranslate nohighlight">\(u_s\)</span> in the body objects <code class="docutils literal notranslate"><span class="pre">body.struct_disps</span></code></p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scenario</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Scenario</span></code>) – The current scenario</p></li>
<li><p><strong>bodies</strong> (list of <code class="xref py py-class docutils literal notranslate"><span class="pre">Body</span></code> objects) – The bodies in the model</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Aerodynamic Solver:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Input the surface deflections</span>
<span class="k">for</span> <span class="n">ibody</span><span class="p">,</span> <span class="n">body</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bodies</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">body</span><span class="o">.</span><span class="n">aero_nnodes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">input_surface_deformation</span><span class="p">(</span><span class="n">ibody</span><span class="p">,</span> <span class="n">body</span><span class="o">.</span><span class="n">aero_disps</span><span class="p">)</span>

<span class="c1"># Advance the solver</span>
<span class="n">solver</span><span class="o">.</span><span class="n">iterate</span><span class="p">()</span>

<span class="c1"># Extract the surface forces</span>
<span class="k">for</span> <span class="n">ibody</span><span class="p">,</span> <span class="n">body</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bodies</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">body</span><span class="o">.</span><span class="n">aero_nnodes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">body</span><span class="o">.</span><span class="n">aero_loads</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">extract_forces</span><span class="p">(</span><span class="n">ibody</span><span class="p">)</span>
</pre></div>
</div>
<p>Structural Solver:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Input the forces on the structure</span>
<span class="k">for</span> <span class="n">ibody</span><span class="p">,</span> <span class="n">body</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bodies</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">body</span><span class="o">.</span><span class="n">aero_nnodes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">input_forces</span><span class="p">(</span><span class="n">ibody</span><span class="p">,</span> <span class="n">body</span><span class="o">.</span><span class="n">struct_loads</span><span class="p">)</span>

<span class="c1"># Advance the solver</span>
<span class="n">solver</span><span class="o">.</span><span class="n">iterate</span><span class="p">()</span>

<span class="c1"># Extract the displacemets</span>
<span class="k">for</span> <span class="n">ibody</span><span class="p">,</span> <span class="n">body</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bodies</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">body</span><span class="o">.</span><span class="n">aero_nnodes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">body</span><span class="o">.</span><span class="n">struct_disps</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">extract_displacements</span><span class="p">(</span><span class="n">ibody</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solver_interface.SolverInterface.post">
<span class="sig-name descname"><span class="pre">post</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scenario</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bodies</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/solver_interface.html#SolverInterface.post"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#solver_interface.SolverInterface.post" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform any tasks the solver needs to do after the forward steps are complete, e.g., evaluate functions, post-process, deallocate unneeded memory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scenario</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Scenario</span></code>) – The current scenario</p></li>
<li><p><strong>bodies</strong> (list of <code class="xref py py-class docutils literal notranslate"><span class="pre">Body</span></code> objects) – The bodies in the model</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solver_interface.SolverInterface.initialize_adjoint">
<span class="sig-name descname"><span class="pre">initialize_adjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scenario</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bodies</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/solver_interface.html#SolverInterface.initialize_adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#solver_interface.SolverInterface.initialize_adjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform any tasks the solver needs to do before taking adjoint steps</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scenario</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Scenario</span></code>) – The current scenario</p></li>
<li><p><strong>bodies</strong> (list of <code class="xref py py-class docutils literal notranslate"><span class="pre">Body</span></code> objects) – The bodies in the model</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solver_interface.SolverInterface.set_states">
<span class="sig-name descname"><span class="pre">set_states</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scenario</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bodies</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/solver_interface.html#SolverInterface.set_states"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#solver_interface.SolverInterface.set_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Load the states (aero_loads, struct_disps) associated with this step either from memory or the disk for the transfer scheme to linearize about.
This function is called at the beginning of each adjoint step in time dependent problems.</p>
<p><strong>Note: in the NLBGS algorithm the transfer scheme uses the structural displacements from the prior step. set_states will request the states from the previous step but then ask the structural solver to linearize about the current step in iterate_adjoint</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scenario</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Scenario</span></code>) – The current scenario</p></li>
<li><p><strong>bodies</strong> (list of <code class="xref py py-class docutils literal notranslate"><span class="pre">Body</span></code> objects) – The bodies in the model</p></li>
<li><p><strong>step</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a>) – The time step number that the driver wants the states from</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Structural Solver:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Find the step&#39;s values on the disk</span>
<span class="n">disps_hist</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">load_state</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>

<span class="c1"># Set the structural displacements for the transfer scheme residuals to linearize about</span>
<span class="k">for</span> <span class="n">ibody</span><span class="p">,</span><span class="n">body</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bodies</span><span class="p">):</span>
    <span class="n">body</span><span class="o">.</span><span class="n">struct_disps</span> <span class="o">=</span> <span class="n">disps_hist</span><span class="p">[</span><span class="n">ibody</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solver_interface.SolverInterface.iterate_adjoint">
<span class="sig-name descname"><span class="pre">iterate_adjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scenario</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bodies</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/solver_interface.html#SolverInterface.iterate_adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#solver_interface.SolverInterface.iterate_adjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjoint iteration for the solver. Typical involves the solver reading in a RHS term then returning an adjoint or adjoint-product.
Called in NLBGS solver.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scenario</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Scenario</span></code>) – The current scenario</p></li>
<li><p><strong>bodies</strong> (list of <code class="xref py py-class docutils literal notranslate"><span class="pre">Body</span></code> objects) – The bodies in the model</p></li>
<li><p><strong>step</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a>) – The step number. Will start at the final step and march backwards to 0, the initial condition.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Aerodynamic Solver:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Read in the force adjoint</span>
<span class="k">for</span> <span class="n">ibody</span><span class="p">,</span> <span class="n">body</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bodies</span><span class="p">):</span>
    <span class="n">solver</span><span class="o">.</span><span class="n">set_force_adjoint</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">psi_F</span><span class="p">)</span>

    <span class="c1"># take a reverse step in the adjoint solver</span>
    <span class="n">solver</span><span class="o">.</span><span class="n">iterate_adjoint</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>

    <span class="c1"># pull out the grid adjoint value</span>
    <span class="k">for</span> <span class="n">ibody</span><span class="p">,</span> <span class="n">body</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bodies</span><span class="p">):</span>
        <span class="n">psi_G</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">get_grid_adjoint</span><span class="p">(</span><span class="n">ibody</span><span class="p">)</span>

        <span class="c1"># &#39;solve&#39; for the displacement adjoint</span>
        <span class="n">body</span><span class="o">.</span><span class="n">psi_D</span> <span class="o">=</span> <span class="o">-</span><span class="n">psi_G</span>
</pre></div>
</div>
<p>Structural Solver:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># put the body RHS&#39;s into the solver bvec</span>
<span class="k">for</span> <span class="n">ibody</span><span class="p">,</span> <span class="n">body</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bodies</span><span class="p">):</span>
    <span class="n">solver</span><span class="o">.</span><span class="n">add_body_rhs_term</span><span class="p">(</span><span class="n">ibody</span><span class="p">,</span> <span class="n">body</span><span class="o">.</span><span class="n">struct_rhs</span><span class="p">)</span>

<span class="c1"># take a reverse step in the adjoint solver</span>
<span class="n">solver</span><span class="o">.</span><span class="n">iterate_adjoint</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>

<span class="c1"># pull out the structural adjoint value</span>
<span class="k">for</span> <span class="n">ibody</span><span class="p">,</span> <span class="n">body</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bodies</span><span class="p">):</span>
    <span class="n">body</span><span class="o">.</span><span class="n">psi_S</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">get_struct_adjoint</span><span class="p">(</span><span class="n">ibody</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solver_interface.SolverInterface.post_adjoint">
<span class="sig-name descname"><span class="pre">post_adjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scenario</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bodies</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/solver_interface.html#SolverInterface.post_adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#solver_interface.SolverInterface.post_adjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Any actions that need to be performed after completing the adjoint solve, e.g., evaluating gradients, deallocating memory, etc.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solver_interface.SolverInterface.step_pre">
<span class="sig-name descname"><span class="pre">step_pre</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scenario</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bodies</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/solver_interface.html#SolverInterface.step_pre"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#solver_interface.SolverInterface.step_pre" title="Permalink to this definition">¶</a></dt>
<dd><p>Operations before at a step in an FSI subiteration case.
Called in NLBGS with FSI subiterations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scenario</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Scenario</span></code>) – The current scenario</p></li>
<li><p><strong>bodies</strong> (list of <code class="xref py py-class docutils literal notranslate"><span class="pre">Body</span></code> objects) – The bodies in the model</p></li>
<li><p><strong>step</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a>) – The step number. Will start at the final step and march backwards to 0, the initial condition.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solver_interface.SolverInterface.step_solver">
<span class="sig-name descname"><span class="pre">step_solver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scenario</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bodies</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fsi_subiter</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/solver_interface.html#SolverInterface.step_solver"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#solver_interface.SolverInterface.step_solver" title="Permalink to this definition">¶</a></dt>
<dd><p>Step in an FSI subiteration case.
Called in NLBGS with FSI subiterations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scenario</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Scenario</span></code>) – The current scenario</p></li>
<li><p><strong>bodies</strong> (list of <code class="xref py py-class docutils literal notranslate"><span class="pre">Body</span></code> objects) – The bodies in the model</p></li>
<li><p><strong>step</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a>) – The step number. Will start at the final step and march backwards to 0, the initial condition.</p></li>
<li><p><strong>fsi_subiter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a>) – The FSI subiteration number</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solver_interface.SolverInterface.step_post">
<span class="sig-name descname"><span class="pre">step_post</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scenario</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bodies</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/solver_interface.html#SolverInterface.step_post"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#solver_interface.SolverInterface.step_post" title="Permalink to this definition">¶</a></dt>
<dd><p>Operations after at a step in an FSI subiteration case.
Called in NLBGS with FSI subiterations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scenario</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Scenario</span></code>) – The current scenario</p></li>
<li><p><strong>bodies</strong> (list of <code class="xref py py-class docutils literal notranslate"><span class="pre">Body</span></code> objects) – The bodies in the model</p></li>
<li><p><strong>step</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a>) – The step number. Will start at the final step and march backwards to 0, the initial condition.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="create-a-body-class-with-shape-parameterization">
<h2>Create a body class with shape parameterization<a class="headerlink" href="#create-a-body-class-with-shape-parameterization" title="Permalink to this heading">¶</a></h2>
<p>To create a shape parameterization, three functions need to added to the body class:</p>
<section id="initialize-shape-parameterization">
<h3>initialize_shape_parameterization()<a class="headerlink" href="#initialize-shape-parameterization" title="Permalink to this heading">¶</a></h3>
</section>
<section id="update-shape">
<h3>update_shape<a class="headerlink" href="#update-shape" title="Permalink to this heading">¶</a></h3>
</section>
<section id="shape-derivative">
<h3>shape_derivative<a class="headerlink" href="#shape-derivative" title="Permalink to this heading">¶</a></h3>
</section>
</section>
<section id="create-a-new-driver">
<h2>Create a new driver<a class="headerlink" href="#create-a-new-driver" title="Permalink to this heading">¶</a></h2>
<p>To create a new driver, you only need to add the algorithms use to solve the coupled equations: _solve_steady_forward, _solve_steady_adjoint, _solve_unsteady_forward, _solve_unsteady_adjoint.
If you are only need either a steady or unsteady driver, you do not need to add the other pair of functions.
The functions are hidden (begin with an underscore) since they should only be called by the driver.
The user should call <code class="xref py py-func docutils literal notranslate"><span class="pre">solve_forward()</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">solve_adjoint()</span></code>.
Within the driver, the programmer has the freedom to make calls in certain order.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Programmer’s Guide</a><ul>
<li><a class="reference internal" href="#create-an-interface-class-for-a-solver">Create an interface class for a solver</a><ul>
<li><a class="reference internal" href="#data-to-be-set-during-initialization">Data to be set during initialization</a></li>
<li><a class="reference internal" href="#module-solver_interface">Solver Interface Class</a></li>
</ul>
</li>
<li><a class="reference internal" href="#create-a-body-class-with-shape-parameterization">Create a body class with shape parameterization</a><ul>
<li><a class="reference internal" href="#initialize-shape-parameterization">initialize_shape_parameterization()</a></li>
<li><a class="reference internal" href="#update-shape">update_shape</a></li>
<li><a class="reference internal" href="#shape-derivative">shape_derivative</a></li>
</ul>
</li>
<li><a class="reference internal" href="#create-a-new-driver">Create a new driver</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="transfer_scheme.html"
                          title="previous chapter">Transfer Scheme</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="py_script.html"
                          title="next chapter">pyFUNtoFEM</a></p>
  </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="py_script.html" title="pyFUNtoFEM"
             >next</a> |</li>
        <li class="right" >
          <a href="transfer_scheme.html" title="Transfer Scheme"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">FUNtoFEM .0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Programmer’s Guide</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021, FUNtoFEM Developers.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.0.2.
    </div>
  </body>
</html>